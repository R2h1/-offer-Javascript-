const asy2 = async () => {
  // 第一组：
  // 微队列：asy2完成（asy2 完成后才将"输出2"放入微队列）
  // 宏任务队列：setTimeout 的回调
  // 同步代码是定时器到时后将 setTimeout 的回调放入任务队列，await timerId 相当于 Promise.resolve(timeId)
  // "asy2 完成" 需要在当前同步代码执行完毕后才能执行，因此 "asy2 完成" 是放入微队列中
  await setTimeout(() => {
    // 将 "输出3" 放入微队列，执行"输出4"
    //    微队列："输出3"
    //    宏任务队列：空
    Promise.resolve().then((_) => {
      console.log(3);
    });
    console.log(4);
  }, 0);

  // 第二组：
  // 微队列："输出4"（"输出4"后才将 "asy2完成" 放入微队列）
  // 宏任务队列：空
  // 同步代码是立即执行函数，执行内部 await 后的函数 "输出3"，将"输出4"放入微队列
  // "输出4"后才将 "asy2完成" 放入微队列
  await (async () => {
    await (() => {
      console.log(3);
    });
    console.log(4);
  })();

  // 第三组
  // 微队列："输出3" "asy2 完成"（asy2 完成后才将"输出2"放入微队列）
  // 宏任务队列：空
  // 同步代码是立即执行函数，将 "输出3" 放入微队列，"输出4"，将 "asy2 完成" 放入微队列
  await (async () => {
    Promise.resolve().then((_) => {
      console.log(3);
    });
    console.log(4);
  })();

  // 第四组
  // 微队列：回调函数1（回调函数1执行完才将 "输出5" 放入微队列）
  // 宏任务队列：空
  // 同步代码是将回调函数1放入微队列，回调函数1执行完才将 "输出5" 放入微队列
  await Promise.resolve().then((_) => {
    // 微队列："输出6" "输出3" "输出5"（执行输出后 "asy2 完成"）
    // 宏任务队列：空
    // 将 "输出3" 放入微队列, 执行"输出4"，回调函数1执行完，将 "输出5" 放入微队列
    Promise.resolve().then((_) => {
      console.log(3);
    });
    console.log(4);
  });
  // 执行 "输出5" 后 "asy2 完成"，将 "输出2" 推入微队列
  console.log(5);
};

async function asy1() {
  console.log(1);
  await asy2();
  console.log(2);
}

const asy3 = async () => {
  // 将 "输出6" 放入微队列
  // 第一组：
  //    微队列："asy2 完成" "输出6"
  //    宏任务队列：setTimeout 的回调
  // 第二组：
  //    微队列："输出4"（"输出4"后才将 "asy2完成" 放入微队列） "输出6"
  //    宏任务队列：空
  // 第三组：
  //    微队列："输出3" "asy2 完成"（asy2 完成后才将"输出2"放入微队列） "输出6"
  //    宏任务队列：空
  // 第四组
  // 微队列：回调函数1（回调函数1执行完才将 "输出5" 放入微队列）"输出6"
  // 宏任务队列：空
  Promise.resolve().then((_) => {
    console.log(6);
  });
};

asy1(); // 执行 asy1 的同步代码，即"输出1"，并执行 asy2，在 asy2 完成后才将"输出2"放入微队列
console.log(7); // 输出 7
asy3(); // 执行 asy3 的同步代码

/**
 * 第一组:
 *   1 7 6 2 4 3
 * 第二组：
 *   1 3 7 4 6 2
 * 第三组：
 *   1 4 7 3 6 2
 * 第四组：
 *   1 7 4 6 3 5 2
 */
