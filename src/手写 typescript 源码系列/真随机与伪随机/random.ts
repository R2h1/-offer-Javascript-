/**
 * 真伪随机在程序原理与应用领域的定义实际上是不同的。
 * 程序原理的真伪随机：
 *  1. 真随机是指通过外置的观测设备，观测某个真正随机的事物的状态。在需要产生随机数的时候，记录该事物的状态值，再以此值经过一定的算法，得到一个真正的随机数。
 *  2. 伪随机是指在系统内部抓取一个程序员自身无法预料准确值的值，把该值作为种子，放进随机数生成器，由此得到一连串随机数的方法。
 *      随机数生成器的核心部分是一个函数f(x)，x 即随机种子
 *      x的确定标准就是要无法预测，比如说可以选取系统开始运行之后的时间(单位毫秒)
 *      根据函数的特性，x的值确定，f(x)的值就唯一且确定，f(x)就是该随机数生成器生成的第一个随机数，记作R_1
 *      (注：R1只是一个胚体，在实际调用的时候，还会用一个不可逆的处理方法使其变成需要的随机数——比如50到300之间的随机数
 *      然后如果还需要第二个随机数，就把R_1放进f()，得到第二个随机数R_2 = f(R_1)
 *      以此类推
 *      R_1 = f(x)
 *      R_2 = f(R_1)
 *      …
 *      R_n = f(R_ n-1)
 *      因此，一旦某个随机数生成器的种子确定，他之后所产生的每一个随机数就都确定了。
 *      虽然如此，但如果你无法查看也无法修改随机种子，那么程序用伪随机方法所产生的随机数在表现出来的效果上就等同于真随机。
 * 
 *      用伪随机进行大规模的模拟，其统计结果也会与数学计算出来的期望相符。
 *      如果暴击率 10%，每次攻击时程序产生一个 1 到 10000 之间的数，处于 1 到 1000 之间时就暴击
 *      连续攻击一万次，你暴击的次数就会在 1000 附近。
 * 
 * 应用领域的真伪随机：
 *    1.真随机就是指每一次几率判断都是独立的（表现为每次产生的随机数种子不一样）。
 *        比如说一个游戏角色的暴击率是20%，那么在真随机的机制下，他的每一次攻击都会是20%的几率暴击。
 *        前一刀暴击了，下一刀是20%暴率，前一刀没爆，下一刀也仍然是20%暴率。
 *    2. 伪随机就是指同一类的概率事件，彼此之间存在关联性。
 *       a. 种子固定；
 *       b. 动态几率：比如说一个游戏角色的暴击率是20%，那么在伪随机的机制下，这个角色每一次攻击的暴击率都是动态变化的。前一刀暴击了，后一刀的爆率就会降低；前一刀没爆，后一刀的爆率就会提升。但是，当这个玩家进行足够多次攻击之后，统计上的暴击率还是会等于20%。
 *          伪随机算法
 *    3. 伪随机算法
 *        a. Pseudo Random Distribution：一个暴击率20%的英雄，并不是每一刀都20%暴击率的。而是以5.57%作为初始暴率，如果第一刀不暴，则第二刀的暴率增加到初始值的2倍：11.14%;如果还是不暴，就继续增加到初始值的3倍：16.71%，以此类推；而如果在这个过程中任何一次攻击打出了暴击，就会把暴击率重置到5.57%。通过验算可以看到，以这种方式实现的暴击，最终表现出来的暴率仍然是20%。
 *        b. 洗牌算法
 *        c. 组合随机：所谓的组合随机，典型的应用就是在抽奖的时候进行两次判断：
                          一次不随机：根据预设好的确定数组，给予玩家对应的chest。
                          这一次主要是用于确定奖品品质。
                          一次真随机：从选中的chest中随机抽取一件物品给玩家。
                          这一次就是从对应品质的奖品堆中随机获取一件物品。
 */
